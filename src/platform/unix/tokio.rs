//! Asynchronous implementation using tokio runtime.
//!
//!
//! ## Channels
//!
//! Asynchronous channels work just like synchronous channels except that you need to add `.await`
//! to each blocking call. Synchronous and asynchronous channels can be converted to each other.
//! This might be useful if you use tokio in the parent process but use synchronous code in the
//! child. In this case, you would create a channel using [`crossmist::channel`] and convert
//! one side to an asynchronous one.
//!
//!
//! ## Processes
//!
//! To start a child process, you use the `spawn_tokio` method generated by `#[func]`:
//!
//! ```ignore
//! #[func]
//! fn my_process() {
//!     ...
//! }
//!
//! let child = my_process.spawn_tokio().await?;
//! ```
//!
//! Note that you can use the `spawn_tokio` method on both synchronous and asynchronous functions,
//! e.g. the following works too:
//!
//! ```ignore
//! #[func]
//! #[tokio::main]
//! async fn my_process() {
//!     ...
//! }
//!
//! let child = my_process.spawn_tokio().await?;
//! ```

use crate::{
    entry, imp,
    internals::{SingleObjectReceiver, SingleObjectSender},
    subprocess, FnOnceObject, Object, Serializer,
};
use nix::libc::pid_t;
use std::io::Result;
use std::marker::PhantomData;
use std::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};
use tokio::io::Interest;
use tokio_seqpacket::UnixSeqpacket;

/// The transmitting side of a unidirectional channel.
///
/// `T` is the type of the objects this side sends via the channel and the other side receives.
#[derive(Object)]
pub struct Sender<T: Object> {
    fd: UnixSeqpacket,
    marker: PhantomData<fn(T)>,
}

/// The receiving side of a unidirectional channel.
///
/// `T` is the type of the objects the other side sends via the channel and this side receives.
#[derive(Object)]
pub struct Receiver<T: Object> {
    fd: UnixSeqpacket,
    marker: PhantomData<fn() -> T>,
}

/// A side of a bidirectional channel.
///
/// `S` is the type of the objects this side sends via the channel and the other side receives, `R`
/// is the type of the objects the other side sends via the channel and this side receives.
#[derive(Object)]
pub struct Duplex<S: Object, R: Object> {
    fd: UnixSeqpacket,
    marker: PhantomData<fn(S) -> R>,
}

/// Create a unidirectional channel.
pub fn channel<T: Object>() -> Result<(Sender<T>, Receiver<T>)> {
    let (tx, rx) = UnixSeqpacket::pair()?;
    unsafe {
        Ok((
            Sender::from_unix_seqpacket(tx),
            Receiver::from_unix_seqpacket(rx),
        ))
    }
}

/// Create a bidirectional channel.
pub fn duplex<A: Object, B: Object>() -> Result<(Duplex<A, B>, Duplex<B, A>)> {
    let (tx, rx) = UnixSeqpacket::pair()?;
    unsafe {
        Ok((
            Duplex::from_unix_seqpacket(tx),
            Duplex::from_unix_seqpacket(rx),
        ))
    }
}

async fn send_on_fd<T: Object>(fd: &UnixSeqpacket, value: &T) -> Result<()> {
    let mut sender = SingleObjectSender::new(fd.as_raw_fd(), value);
    fd.as_async_fd()
        .async_io(Interest::WRITABLE, |_| sender.send_next())
        .await
}

async unsafe fn recv_on_fd<T: Object>(fd: &UnixSeqpacket) -> Result<Option<T>> {
    let mut receiver = SingleObjectReceiver::new(fd.as_raw_fd());
    fd.as_async_fd()
        .async_io(Interest::READABLE, |_| receiver.recv_next())
        .await
}

impl<T: Object> Sender<T> {
    unsafe fn from_unix_seqpacket(fd: UnixSeqpacket) -> Self {
        Sender {
            fd,
            marker: PhantomData,
        }
    }

    /// Send a value to the other side.
    pub async fn send(&mut self, value: &T) -> Result<()> {
        send_on_fd(&self.fd, value).await
    }
}

impl<T: Object> From<crate::Sender<T>> for Sender<T> {
    fn from(value: crate::Sender<T>) -> Self {
        unsafe {
            let fd = value.into_raw_fd();
            entry::enable_nonblock(fd).expect("Failed to set O_NONBLOCK");
            Self::from_raw_fd(fd)
        }
    }
}
impl<T: Object> From<Sender<T>> for crate::Sender<T> {
    fn from(value: Sender<T>) -> Self {
        unsafe {
            let fd = value.into_raw_fd();
            entry::disable_nonblock(fd).expect("Failed to reset O_NONBLOCK");
            Self::from_raw_fd(fd)
        }
    }
}

impl<T: Object> AsRawFd for Sender<T> {
    fn as_raw_fd(&self) -> RawFd {
        self.fd.as_raw_fd()
    }
}

impl<T: Object> IntoRawFd for Sender<T> {
    fn into_raw_fd(self) -> RawFd {
        self.fd.into_raw_fd()
    }
}

impl<T: Object> FromRawFd for Sender<T> {
    unsafe fn from_raw_fd(fd: RawFd) -> Self {
        Self::from_unix_seqpacket(
            UnixSeqpacket::from_raw_fd(fd)
                .expect("Failed to register fd in tokio in crossmist::tokio::Sender::from_raw_fd"),
        )
    }
}

impl<T: Object> Receiver<T> {
    unsafe fn from_unix_seqpacket(fd: UnixSeqpacket) -> Self {
        Receiver {
            fd,
            marker: PhantomData,
        }
    }

    /// Receive a value from the other side.
    ///
    /// Returns `Ok(None)` if the other side has dropped the channel.
    pub async fn recv(&mut self) -> Result<Option<T>> {
        unsafe { recv_on_fd(&self.fd).await }
    }
}

impl<T: Object> From<crate::Receiver<T>> for Receiver<T> {
    fn from(value: crate::Receiver<T>) -> Self {
        unsafe {
            let fd = value.into_raw_fd();
            entry::enable_nonblock(fd).expect("Failed to set O_NONBLOCK");
            Self::from_raw_fd(fd)
        }
    }
}
impl<T: Object> From<Receiver<T>> for crate::Receiver<T> {
    fn from(value: Receiver<T>) -> Self {
        unsafe {
            let fd = value.into_raw_fd();
            entry::disable_nonblock(fd).expect("Failed to reset O_NONBLOCK");
            Self::from_raw_fd(fd)
        }
    }
}

impl<T: Object> AsRawFd for Receiver<T> {
    fn as_raw_fd(&self) -> RawFd {
        self.fd.as_raw_fd()
    }
}

impl<T: Object> IntoRawFd for Receiver<T> {
    fn into_raw_fd(self) -> RawFd {
        self.fd.into_raw_fd()
    }
}

impl<T: Object> FromRawFd for Receiver<T> {
    unsafe fn from_raw_fd(fd: RawFd) -> Self {
        Self::from_unix_seqpacket(
            UnixSeqpacket::from_raw_fd(fd).expect(
                "Failed to register fd in tokio in crossmist::tokio::Receiver::from_raw_fd",
            ),
        )
    }
}

impl<S: Object, R: Object> Duplex<S, R> {
    unsafe fn from_unix_seqpacket(fd: UnixSeqpacket) -> Self {
        Duplex {
            fd,
            marker: PhantomData,
        }
    }

    /// Send a value to the other side.
    pub async fn send(&mut self, value: &S) -> Result<()> {
        send_on_fd(&self.fd, value).await
    }

    /// Receive a value from the other side.
    ///
    /// Returns `Ok(None)` if the other side has dropped the channel.
    pub async fn recv(&mut self) -> Result<Option<R>> {
        unsafe { recv_on_fd(&self.fd).await }
    }

    /// Send a value from the other side and wait for a response immediately.
    ///
    /// If the other side closes the channel before responding, an error is returned.
    pub async fn request(&mut self, value: &S) -> Result<R> {
        self.send(value).await?;
        self.recv().await?.ok_or_else(|| {
            std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "The subprocess exitted before responding to the request",
            )
        })
    }

    fn into_receiver(self) -> Receiver<R> {
        unsafe { Receiver::from_unix_seqpacket(self.fd) }
    }
}

impl<S: Object, R: Object> From<crate::Duplex<S, R>> for Duplex<S, R> {
    fn from(value: crate::Duplex<S, R>) -> Self {
        unsafe {
            let fd = value.into_raw_fd();
            entry::enable_nonblock(fd).expect("Failed to set O_NONBLOCK");
            Self::from_raw_fd(fd)
        }
    }
}
impl<S: Object, R: Object> From<Duplex<S, R>> for crate::Duplex<S, R> {
    fn from(value: Duplex<S, R>) -> Self {
        unsafe {
            let fd = value.into_raw_fd();
            entry::disable_nonblock(fd).expect("Failed to reset O_NONBLOCK");
            Self::from_raw_fd(fd)
        }
    }
}

impl<S: Object, R: Object> AsRawFd for Duplex<S, R> {
    fn as_raw_fd(&self) -> RawFd {
        self.fd.as_raw_fd()
    }
}

impl<S: Object, R: Object> IntoRawFd for Duplex<S, R> {
    fn into_raw_fd(self) -> RawFd {
        self.fd.into_raw_fd()
    }
}

impl<S: Object, R: Object> FromRawFd for Duplex<S, R> {
    unsafe fn from_raw_fd(fd: RawFd) -> Self {
        Self::from_unix_seqpacket(
            UnixSeqpacket::from_raw_fd(fd)
                .expect("Failed to register fd in tokio in crossmist::tokio::Duplex::from_raw_fd"),
        )
    }
}

/// The subprocess object created by calling `spawn_tokio` on a function annottated with `#[func]`.
pub struct Child<T: Object> {
    proc_pid: nix::unistd::Pid,
    output_rx: Receiver<T>,
}

impl<T: Object> Child<T> {
    fn new(proc_pid: nix::unistd::Pid, output_rx: Receiver<T>) -> Child<T> {
        Child {
            proc_pid,
            output_rx,
        }
    }

    /// Terminate the process immediately.
    pub fn kill(&mut self) -> Result<()> {
        nix::sys::signal::kill(self.proc_pid, nix::sys::signal::Signal::SIGKILL)?;
        Ok(())
    }

    /// Get ID of the process.
    pub fn id(&self) -> pid_t {
        self.proc_pid.as_raw()
    }

    /// Wait for the process to finish and obtain the value it returns.
    ///
    /// An error is returned if the process panics or is terminated. An error is also delivered if
    /// it exits via [`std::process::exit`] or alike instead of returning a value, unless the return
    /// type is `()`. In that case, `Ok(())` is returned.
    pub async fn join(mut self) -> Result<T> {
        let mut value = self.output_rx.recv().await?;
        // Avoid receiving a void result -- merely dropping the channel on the other side suffices
        if let Some(void) = imp::if_void::<T>() {
            // The value should be None at this moment
            value = Some(void);
        }
        // This is synchronous, but should be really fast
        let status = nix::sys::wait::waitpid(self.proc_pid, None)?;
        if let nix::sys::wait::WaitStatus::Exited(_, 0) = status {
            value.ok_or_else(|| {
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    "The subprocess terminated without returning a value",
                )
            })
        } else {
            Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!(
                    "The subprocess did not terminate successfully: {:?}",
                    status
                ),
            ))
        }
    }
}

#[doc(hidden)]
pub async unsafe fn spawn<T: Object>(
    entry: Box<dyn FnOnceObject<(RawFd,), Output = i32>>,
) -> Result<Child<T>> {
    imp::perform_sanity_checks();

    let mut s = Serializer::new();
    s.serialize(&entry);

    let fds = s.drain_handles();

    let (mut local, child) = duplex::<(Vec<u8>, Vec<RawFd>), T>()?;
    let pid = subprocess::_spawn_child(child.as_raw_fd(), &fds)?;
    local.send(&(s.into_vec(), fds)).await?;

    Ok(Child::new(pid, local.into_receiver()))
}
