//! Asynchronous implementation using tokio runtime.
//!
//!
//! ## Channels
//!
//! Asynchronous channels work just like synchronous channels except that you need to add `.await`
//! to each blocking call. Synchronous and asynchronous channels can be converted to each other.
//! This might be useful if you use tokio in the parent process but use synchronous code in the
//! child. In this case, you would create a channel using [`crossmist::channel`] and convert
//! one side to an asynchronous one.
//!
//!
//! ## Processes
//!
//! To start a child process, you use the `spawn_tokio` method generated by `#[func]`:
//!
//! ```ignore
//! #[func]
//! fn my_process() {
//!     ...
//! }
//!
//! let child = my_process.spawn_tokio().await?;
//! ```
//!
//! Note that you can use the `spawn_tokio` method on both synchronous and asynchronous functions,
//! e.g. the following works too:
//!
//! ```ignore
//! #[func]
//! #[tokio::main]
//! async fn my_process() {
//!     ...
//! }
//!
//! let child = my_process.spawn_tokio().await?;
//! ```

use crate::{
    handles, handles::OwnedHandle, subprocess, Deserializer, FnOnceObject, Object, Serializer,
};
use std::ffi::c_void;
use std::io::{Error, ErrorKind, Result};
use std::marker::PhantomData;
use std::os::windows::{
    io,
    io::{FromRawHandle, IntoRawHandle, RawHandle},
};
use tokio::{
    fs::File,
    io::{AsyncReadExt, AsyncWriteExt},
};
use windows::Win32::System::{Pipes, Threading, WindowsProgramming};

/// The transmitting side of a unidirectional channel.
///
/// `T` is the type of the objects this side sends via the channel and the other side receives.
#[derive(Object)]
pub struct Sender<T: Object> {
    file: File,
    marker: PhantomData<fn(T) -> T>,
}

/// The receiving side of a unidirectional channel.
///
/// `T` is the type of the objects the other side sends via the channel and this side receives.
#[derive(Object)]
pub struct Receiver<T: Object> {
    file: File,
    marker: PhantomData<fn(T) -> T>,
}

/// A side of a bidirectional channel.
///
/// `S` is the type of the objects this side sends via the channel and the other side receives, `R`
/// is the type of the objects the other side sends via the channel and this side receives.
#[derive(Object)]
pub struct Duplex<S: Object, R: Object> {
    sender_file: File,
    receiver_file: File,
    marker: PhantomData<fn(S, R) -> (S, R)>,
}

/// Create a unidirectional channel.
pub fn channel<T: Object>() -> Result<(Sender<T>, Receiver<T>)> {
    let mut tx: handles::RawHandle = Default::default();
    let mut rx: handles::RawHandle = Default::default();
    unsafe {
        Pipes::CreatePipe(
            &mut rx as *mut handles::RawHandle,
            &mut tx as *mut handles::RawHandle,
            std::ptr::null(),
            0,
        )
        .ok()?;
    }
    let tx = Sender {
        file: unsafe { File::from_raw_handle(tx.0 as *mut c_void) },
        marker: PhantomData,
    };
    let rx = Receiver {
        file: unsafe { File::from_raw_handle(rx.0 as *mut c_void) },
        marker: PhantomData,
    };
    Ok((tx, rx))
}

/// Create a bidirectional channel.
pub fn duplex<A: Object, B: Object>() -> Result<(Duplex<A, B>, Duplex<B, A>)> {
    let (tx_a, rx_a) = channel::<A>()?;
    let (tx_b, rx_b) = channel::<B>()?;
    let ours = Duplex {
        sender_file: tx_a.file,
        receiver_file: rx_b.file,
        marker: PhantomData,
    };
    let theirs = Duplex {
        sender_file: tx_b.file,
        receiver_file: rx_a.file,
        marker: PhantomData,
    };
    Ok((ours, theirs))
}

async fn send_on_handle<T: Object>(file: &mut File, value: &T) -> Result<()> {
    let serialized = {
        let mut s = Serializer::new();
        s.serialize(value);

        let handles = s.drain_handles();
        if !handles.is_empty() {
            return Err(Error::new(
                ErrorKind::Other,
                "The message contains attached handles",
            ));
        }

        s.into_vec()
    };
    file.write_all(&serialized.len().to_ne_bytes()).await?;
    file.write_all(&serialized).await
}

async fn recv_on_handle<T: Object>(file: &mut File) -> Result<Option<T>> {
    let mut len = [0u8; std::mem::size_of::<usize>()];
    if let Err(e) = file.read_exact(&mut len).await {
        if e.kind() == ErrorKind::UnexpectedEof {
            return Ok(None);
        }
        return Err(e);
    }
    let len = usize::from_ne_bytes(len);

    let mut serialized = vec![0u8; len];
    file.read_exact(&mut serialized).await?;

    let mut d = Deserializer::from(serialized, Vec::new());
    Ok(Some(d.deserialize()))
}

impl<T: Object> Sender<T> {
    fn from_file(file: File) -> Self {
        Sender {
            file,
            marker: PhantomData,
        }
    }

    /// Send a value to the other side.
    pub async fn send(&mut self, value: &T) -> Result<()> {
        send_on_handle(&mut self.file, value).await
    }
}

impl<T: Object> From<crate::Sender<T>> for Sender<T> {
    fn from(value: crate::Sender<T>) -> Self {
        unsafe { Self::from_raw_handle(value.into_raw_handle()) }
    }
}
impl<T: Object> From<Sender<T>> for crate::Sender<T> {
    fn from(value: Sender<T>) -> Self {
        unsafe { Self::from_raw_handle(value.into_raw_handle()) }
    }
}

impl<T: Object> io::AsRawHandle for Sender<T> {
    fn as_raw_handle(&self) -> RawHandle {
        self.file.as_raw_handle()
    }
}

impl<T: Object> IntoRawHandle for Sender<T> {
    fn into_raw_handle(self) -> RawHandle {
        self.file
            .try_into_std()
            .expect("Unexpected in-flight operation")
            .into_raw_handle()
    }
}

impl<T: Object> FromRawHandle for Sender<T> {
    unsafe fn from_raw_handle(handle: RawHandle) -> Self {
        Self::from_file(File::from_raw_handle(handle))
    }
}

impl<T: Object> Receiver<T> {
    fn from_file(file: File) -> Self {
        Receiver {
            file,
            marker: PhantomData,
        }
    }

    /// Receive a value from the other side.
    ///
    /// Returns `Ok(None)` if the other side has dropped the channel.
    pub async fn recv(&mut self) -> Result<Option<T>> {
        recv_on_handle(&mut self.file).await
    }
}

impl<T: Object> From<crate::Receiver<T>> for Receiver<T> {
    fn from(value: crate::Receiver<T>) -> Self {
        unsafe { Self::from_raw_handle(value.into_raw_handle()) }
    }
}
impl<T: Object> From<Receiver<T>> for crate::Receiver<T> {
    fn from(value: Receiver<T>) -> Self {
        unsafe { Self::from_raw_handle(value.into_raw_handle()) }
    }
}

impl<T: Object> io::AsRawHandle for Receiver<T> {
    fn as_raw_handle(&self) -> RawHandle {
        self.file.as_raw_handle()
    }
}

impl<T: Object> IntoRawHandle for Receiver<T> {
    fn into_raw_handle(self) -> RawHandle {
        self.file
            .try_into_std()
            .expect("Unexpected in-flight operation")
            .into_raw_handle()
    }
}

impl<T: Object> FromRawHandle for Receiver<T> {
    unsafe fn from_raw_handle(handle: RawHandle) -> Self {
        Self::from_file(File::from_raw_handle(handle))
    }
}

impl<S: Object, R: Object> Duplex<S, R> {
    /// Send a value to the other side.
    pub async fn send(&mut self, value: &S) -> Result<()> {
        send_on_handle(&mut self.sender_file, value).await
    }

    /// Receive a value from the other side.
    ///
    /// Returns `Ok(None)` if the other side has dropped the channel.
    pub async fn recv(&mut self) -> Result<Option<R>> {
        recv_on_handle(&mut self.receiver_file).await
    }

    /// Send a value from the other side and wait for a response immediately.
    ///
    /// If the other side closes the channel before responding, an error is returned.
    pub async fn request(&mut self, value: &S) -> Result<R> {
        self.send(value).await?;
        self.recv().await?.ok_or_else(|| {
            std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "The subprocess exitted before responding to the request",
            )
        })
    }

    #[doc(hidden)]
    pub fn join(sender: Sender<S>, receiver: Receiver<R>) -> Self {
        Self {
            sender_file: sender.file,
            receiver_file: receiver.file,
            marker: PhantomData,
        }
    }

    #[doc(hidden)]
    pub fn split(self) -> (Sender<S>, Receiver<R>) {
        (
            Sender {
                file: self.sender_file,
                marker: PhantomData,
            },
            Receiver {
                file: self.receiver_file,
                marker: PhantomData,
            },
        )
    }
}

impl<S: Object, R: Object> From<crate::Duplex<S, R>> for Duplex<S, R> {
    fn from(value: crate::Duplex<S, R>) -> Self {
        let (sender, receiver) = value.split();
        Self::join(sender.into(), receiver.into())
    }
}
impl<S: Object, R: Object> From<Duplex<S, R>> for crate::Duplex<S, R> {
    fn from(value: Duplex<S, R>) -> Self {
        let (sender, receiver) = value.split();
        Self::join(sender.into(), receiver.into())
    }
}

/// The subprocess object created by calling `spawn_tokio` on a function annottated with `#[func]`.
pub struct Child<T: Object> {
    proc_handle: OwnedHandle,
    output_rx: Receiver<T>,
}

impl<T: Object> Child<T> {
    fn new(proc_handle: OwnedHandle, output_rx: Receiver<T>) -> Child<T> {
        Child {
            proc_handle,
            output_rx,
        }
    }

    /// Terminate the process immediately.
    pub fn kill(&mut self) -> Result<()> {
        use handles::AsRawHandle;
        unsafe {
            Threading::TerminateProcess(self.proc_handle.as_raw_handle(), 1).ok()?;
        }
        Ok(())
    }

    /// Get ID of the process.
    pub fn id(&self) -> handles::RawHandle {
        use handles::AsRawHandle;
        self.proc_handle.as_raw_handle()
    }

    /// Wait for the process to finish and obtain the value it returns.
    ///
    /// An error is returned if the process panics, is terminated, or exits via
    /// [`std::process::exit`] or alike instead of returning a
    /// value.
    pub async fn join(&mut self) -> Result<T> {
        use handles::AsRawHandle;
        let value = self.output_rx.recv().await?;
        // This is synchronous, but should be really fast
        if unsafe {
            Threading::WaitForSingleObject(
                self.proc_handle.as_raw_handle(),
                WindowsProgramming::INFINITE,
            )
        } == u32::MAX
        {
            return Err(Error::last_os_error());
        }
        let mut code: u32 = 0;
        unsafe {
            Threading::GetExitCodeProcess(self.proc_handle.as_raw_handle(), &mut code as *mut u32)
                .ok()?;
        }
        if code == 0 {
            value.ok_or_else(|| {
                Error::new(
                    ErrorKind::Other,
                    "The subprocess terminated without returning a value",
                )
            })
        } else {
            Err(Error::new(
                ErrorKind::Other,
                format!("The subprocess terminated with exit code {code}"),
            ))
        }
    }
}

#[doc(hidden)]
pub async unsafe fn spawn<T: Object>(
    entry: Box<dyn FnOnceObject<(handles::RawHandle,), Output = i32>>,
    flags: subprocess::Flags,
) -> Result<Child<T>> {
    use handles::AsRawHandle;

    let mut s = Serializer::new();
    s.serialize(&entry);

    let handles = s.drain_handles();

    let (mut local, child) = duplex::<(Vec<u8>, Vec<handles::RawHandle>), T>()?;
    let (child_tx, child_rx) = child.split();
    let handle = subprocess::_spawn_child(
        child_tx.as_raw_handle(),
        child_rx.as_raw_handle(),
        flags,
        &handles,
    )?;
    local.send(&(s.into_vec(), handles)).await?;

    let (_, receiver) = local.split();
    Ok(Child::new(handle, receiver))
}
