//! Generic asynchronous implementation.
//!
//! This module contains generic definitions for functions using arbitrary asynchronous runtimes.
//! The [`crossmist::tokio`] and [`crossmist::smol`] modules provides type and functions definitions
//! for their respective runtimes. You should probably use those.
//!
//!
//! ## Channels
//!
//! Asynchronous channels work just like synchronous channels except that you need to add `.await`
//! to each blocking call. Synchronous and asynchronous channels can be converted to each other.
//! This might be useful if you use tokio/smol in the parent process but use synchronous code in the
//! child. In this case, you would create a channel using [`crossmist::channel`] and convert one
//! side to an asynchronous one.
//!
//!
//! ## Processes
//!
//! To start a child process, you use any of the `spawn_tokio` and `spawn_smol` methods generated by
//! `#[func]`:
//!
//! ```ignore
//! #[func]
//! fn my_process() {
//!     ...
//! }
//!
//! let child = my_process.spawn_tokio().await?;
//! // let child = my_process.spawn_smol().await?;
//! ```
//!
//! Note that you can use these methods on both synchronous and asynchronous functions, e.g. the
//! following works too:
//!
//! ```ignore
//! #[func(tokio)]
//! async fn my_process() {
//!     ...
//! }
//!
//! let child = my_process.spawn_tokio().await?;
//! ```

use crate::{
    handles, handles::OwnedHandle, imp, ipc, subprocess, FnOnceObject, Object, Serializer,
};
use std::ffi::c_void;
use std::fs::File;
use std::future::Future;
use std::io::{Error, ErrorKind, Result};
use std::marker::PhantomData;
use std::os::windows::{
    io,
    io::{FromRawHandle, IntoRawHandle, RawHandle},
};
use windows::Win32::System::{Pipes, Threading, WindowsProgramming};

/// Runtime-dependent parameters.
pub unsafe trait AsyncRuntime {
    /// A readable and writable pipe.
    type Stream: From<File> + Object + handles::AsRawHandle;

    /// Perform a write.
    fn write(stream: &mut Self::Stream, buf: &[u8]) -> impl Future<Output = Result<()>> + Send;

    /// Perform a read.
    fn read(stream: &mut Self::Stream, buf: &mut [u8]) -> impl Future<Output = Result<()>> + Send;
}

/// The transmitting side of a unidirectional channel.
///
/// `T` is the type of the objects this side sends via the channel and the other side receives.
#[derive(Object)]
pub struct Sender<Runtime: AsyncRuntime, T: Object> {
    fd: Runtime::Stream,
    marker: PhantomData<fn(T)>,
}

/// The receiving side of a unidirectional channel.
///
/// `T` is the type of the objects the other side sends via the channel and this side receives.
#[derive(Object)]
pub struct Receiver<Runtime: AsyncRuntime, T: Object> {
    fd: Runtime::Stream,
    marker: PhantomData<fn() -> T>,
}

/// A side of a bidirectional channel.
///
/// `S` is the type of the objects this side sends via the channel and the other side receives, `R`
/// is the type of the objects the other side sends via the channel and this side receives.
#[derive(Object)]
pub struct Duplex<Runtime: AsyncRuntime, S: Object, R: Object> {
    sender: Sender<Runtime, S>,
    receiver: Receiver<Runtime, R>,
}

/// Create a unidirectional channel.
pub fn channel<Runtime: AsyncRuntime, T: Object>(
) -> Result<(Sender<Runtime, T>, Receiver<Runtime, T>)> {
    let mut tx: handles::RawHandle = Default::default();
    let mut rx: handles::RawHandle = Default::default();
    unsafe {
        Pipes::CreatePipe(
            &mut rx as *mut handles::RawHandle,
            &mut tx as *mut handles::RawHandle,
            std::ptr::null(),
            0,
        )
        .ok()?;
    }
    let tx = Sender {
        fd: unsafe { File::from_raw_handle(tx.0 as *mut c_void) }.into(),
        marker: PhantomData,
    };
    let rx = Receiver {
        fd: unsafe { File::from_raw_handle(rx.0 as *mut c_void) }.into(),
        marker: PhantomData,
    };
    Ok((tx, rx))
}

/// Create a bidirectional channel.
pub fn duplex<Runtime: AsyncRuntime, A: Object, B: Object>(
) -> Result<(Duplex<Runtime, A, B>, Duplex<Runtime, B, A>)> {
    let (tx_a, rx_a) = channel::<Runtime, A>()?;
    let (tx_b, rx_b) = channel::<Runtime, B>()?;
    let ours = Duplex {
        sender: tx_a,
        receiver: rx_b,
    };
    let theirs = Duplex {
        sender: tx_b,
        receiver: rx_a,
    };
    Ok((ours, theirs))
}

impl<Runtime: AsyncRuntime, T: Object> Sender<Runtime, T> {
    unsafe fn from_stream(fd: Runtime::Stream) -> Self {
        Sender {
            fd,
            marker: PhantomData,
        }
    }

    /// Send a value to the other side.
    pub async fn send(&mut self, value: &T) -> Result<()> {
        let serialized = ipc::serialize_with_handles(value)?;
        Runtime::write(&mut self.fd, &serialized.len().to_ne_bytes()).await?;
        Runtime::write(&mut self.fd, &serialized).await
    }
}

impl<Runtime: AsyncRuntime, T: Object> TryFrom<crate::Sender<T>> for Sender<Runtime, T> {
    type Error = std::io::Error;
    fn try_from(value: crate::Sender<T>) -> Result<Self> {
        unsafe {
            Ok(Self::from_stream(
                File::from_raw_handle(value.into_raw_handle()).into(),
            ))
        }
    }
}
impl<Runtime: AsyncRuntime, T: Object> From<Sender<Runtime, T>> for crate::Sender<T> {
    fn from(value: Sender<Runtime, T>) -> Self {
        unsafe { Self::from_raw_handle(value.into_raw_handle()) }
    }
}

impl<Runtime: AsyncRuntime, T: Object> io::AsRawHandle for Sender<Runtime, T> {
    fn as_raw_handle(&self) -> RawHandle {
        self.fd.as_raw_handle()
    }
}

impl<Runtime: AsyncRuntime, T: Object> IntoRawHandle for Sender<Runtime, T> {
    fn into_raw_handle(self) -> RawHandle {
        use io::AsRawHandle;
        let fd = self.as_raw_handle();
        std::mem::forget(self);
        fd
    }
}

impl<Runtime: AsyncRuntime, T: Object> Receiver<Runtime, T> {
    unsafe fn from_stream(fd: Runtime::Stream) -> Self {
        Receiver {
            fd,
            marker: PhantomData,
        }
    }

    /// Receive a value from the other side.
    ///
    /// Returns `Ok(None)` if the other side has dropped the channel.
    pub async fn recv(&mut self) -> Result<Option<T>> {
        let mut len = [0u8; std::mem::size_of::<usize>()];
        if let Err(e) = Runtime::read(&mut self.fd, &mut len).await {
            if e.kind() == ErrorKind::UnexpectedEof {
                return Ok(None);
            }
            return Err(e);
        }
        let len = usize::from_ne_bytes(len);

        let mut serialized = vec![0u8; len];
        Runtime::read(&mut self.fd, &mut serialized).await?;

        unsafe { ipc::deserialize_with_handles(serialized).map(Some) }
    }
}

impl<Runtime: AsyncRuntime, T: Object> TryFrom<crate::Receiver<T>> for Receiver<Runtime, T> {
    type Error = std::io::Error;
    fn try_from(value: crate::Receiver<T>) -> Result<Self> {
        unsafe {
            Ok(Self::from_stream(
                File::from_raw_handle(value.into_raw_handle()).into(),
            ))
        }
    }
}
impl<Runtime: AsyncRuntime, T: Object> From<Receiver<Runtime, T>> for crate::Receiver<T> {
    fn from(value: Receiver<Runtime, T>) -> Self {
        unsafe { Self::from_raw_handle(value.into_raw_handle()) }
    }
}

impl<Runtime: AsyncRuntime, T: Object> io::AsRawHandle for Receiver<Runtime, T> {
    fn as_raw_handle(&self) -> RawHandle {
        self.fd.as_raw_handle()
    }
}

impl<Runtime: AsyncRuntime, T: Object> IntoRawHandle for Receiver<Runtime, T> {
    fn into_raw_handle(self) -> RawHandle {
        use io::AsRawHandle;
        let fd = self.as_raw_handle();
        std::mem::forget(self);
        fd
    }
}

impl<Runtime: AsyncRuntime, S: Object, R: Object> Duplex<Runtime, S, R> {
    /// Send a value to the other side.
    pub async fn send(&mut self, value: &S) -> Result<()> {
        self.sender.send(value).await
    }

    /// Receive a value from the other side.
    ///
    /// Returns `Ok(None)` if the other side has dropped the channel.
    pub async fn recv(&mut self) -> Result<Option<R>> {
        self.receiver.recv().await
    }

    /// Send a value from the other side and wait for a response immediately.
    ///
    /// If the other side closes the channel before responding, an error is returned.
    pub async fn request(&mut self, value: &S) -> Result<R> {
        self.send(value).await?;
        self.recv().await?.ok_or_else(|| {
            std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "The subprocess exitted before responding to the request",
            )
        })
    }

    fn join(sender: Sender<Runtime, S>, receiver: Receiver<Runtime, R>) -> Self {
        Self { sender, receiver }
    }

    fn split(self) -> (Sender<Runtime, S>, Receiver<Runtime, R>) {
        (self.sender, self.receiver)
    }
}

impl<Runtime: AsyncRuntime, S: Object, R: Object> TryFrom<crate::Duplex<S, R>>
    for Duplex<Runtime, S, R>
{
    type Error = std::io::Error;
    fn try_from(value: crate::Duplex<S, R>) -> Result<Self> {
        let (sender, receiver) = value.split();
        Ok(Self::join(sender.try_into()?, receiver.try_into()?))
    }
}
impl<Runtime: AsyncRuntime, S: Object, R: Object> From<Duplex<Runtime, S, R>>
    for crate::Duplex<S, R>
{
    fn from(value: Duplex<Runtime, S, R>) -> Self {
        let (sender, receiver) = value.split();
        Self::join(sender.into(), receiver.into())
    }
}

/// A subprocess.
pub struct Child<Runtime: AsyncRuntime, T: Object> {
    proc_handle: OwnedHandle,
    output_rx: Receiver<Runtime, T>,
}

impl<Runtime: AsyncRuntime, T: Object> Child<Runtime, T> {
    fn new(proc_handle: OwnedHandle, output_rx: Receiver<Runtime, T>) -> Child<Runtime, T> {
        Child {
            proc_handle,
            output_rx,
        }
    }

    /// Terminate the process immediately.
    pub fn kill(&mut self) -> Result<()> {
        use handles::AsRawHandle;
        unsafe {
            Threading::TerminateProcess(self.proc_handle.as_raw_handle(), 1).ok()?;
        }
        Ok(())
    }

    /// Get ID of the process.
    pub fn id(&self) -> handles::RawHandle {
        use handles::AsRawHandle;
        self.proc_handle.as_raw_handle()
    }

    /// Wait for the process to finish and obtain the value it returns.
    ///
    /// An error is returned if the process panics or is terminated. An error is also delivered if
    /// it exits via [`std::process::exit`] or alike instead of returning a value, unless the return
    /// type is `()`. In that case, `Ok(())` is returned.
    pub async fn join(mut self) -> Result<T> {
        use handles::AsRawHandle;
        let mut value = self.output_rx.recv().await?;
        if let Some(void) = imp::if_void::<T>() {
            // The value should be None at this moment
            value = Some(void);
        }
        // This is synchronous, but should be really fast
        if unsafe {
            Threading::WaitForSingleObject(
                self.proc_handle.as_raw_handle(),
                WindowsProgramming::INFINITE,
            )
        } == u32::MAX
        {
            return Err(Error::last_os_error());
        }
        let mut code: u32 = 0;
        unsafe {
            Threading::GetExitCodeProcess(self.proc_handle.as_raw_handle(), &mut code as *mut u32)
                .ok()?;
        }
        if code == 0 {
            value.ok_or_else(|| {
                Error::new(
                    ErrorKind::Other,
                    "The subprocess terminated without returning a value",
                )
            })
        } else {
            Err(Error::new(
                ErrorKind::Other,
                format!("The subprocess terminated with exit code {code}"),
            ))
        }
    }
}

pub(crate) async unsafe fn spawn<Runtime: AsyncRuntime, T: Object>(
    entry: Box<dyn FnOnceObject<(handles::RawHandle,), Output = i32>>,
) -> Result<Child<Runtime, T>> {
    use handles::AsRawHandle;

    imp::perform_sanity_checks();

    let mut s = Serializer::new();
    s.serialize(&entry);

    let handles = s.drain_handles();

    let (mut local, child) = duplex::<Runtime, (Vec<u8>, Vec<handles::RawHandle>), T>()?;
    let (child_tx, child_rx) = child.split();
    let handle =
        subprocess::_spawn_child(child_tx.as_raw_handle(), child_rx.as_raw_handle(), &handles)?;
    local.send(&(s.into_vec(), handles)).await?;

    let (_, receiver) = local.split();
    Ok(Child::new(handle, receiver))
}
